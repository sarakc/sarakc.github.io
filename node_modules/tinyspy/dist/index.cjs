"use strict";
<<<<<<< HEAD
var w = Object.defineProperty;
var M = Object.getOwnPropertyDescriptor;
=======
var k = Object.defineProperty;
var C = Object.getOwnPropertyDescriptor;
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
var E = Object.getOwnPropertyNames;
var G = Object.prototype.hasOwnProperty;
var j = (e, t) => {
  for (var n in t)
<<<<<<< HEAD
    w(e, n, { get: t[n], enumerable: !0 });
}, D = (e, t, n, s) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let r of E(t))
      !G.call(e, r) && r !== n && w(e, r, { get: () => t[r], enumerable: !(s = M(t, r)) || s.enumerable });
  return e;
};
var F = (e) => D(w({}, "__esModule", { value: !0 }), e);
=======
    k(e, n, { get: t[n], enumerable: !0 });
}, D = (e, t, n, a) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let r of E(t))
      !G.call(e, r) && r !== n && k(e, r, { get: () => t[r], enumerable: !(a = C(t, r)) || a.enumerable });
  return e;
};
var F = (e) => D(k({}, "__esModule", { value: !0 }), e);
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1

// src/index.ts
var B = {};
j(B, {
<<<<<<< HEAD
  createInternalSpy: () => g,
  getInternalState: () => I,
  internalSpyOn: () => K,
  restoreAll: () => z,
  spies: () => d,
=======
  createInternalSpy: () => I,
  getInternalState: () => T,
  internalSpyOn: () => K,
  restoreAll: () => z,
  spies: () => x,
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
  spy: () => _,
  spyOn: () => $
});
module.exports = F(B);

// src/utils.ts
<<<<<<< HEAD
function R(e, t) {
  if (!e)
    throw new Error(t);
}
function u(e, t) {
=======
function m(e, t) {
  if (!e)
    throw new Error(t);
}
function y(e, t) {
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
  return typeof t === e;
}
function b(e) {
  return e instanceof Promise;
}
<<<<<<< HEAD
function f(e, t, n) {
  Object.defineProperty(e, t, n);
}
function i(e, t, n) {
=======
function d(e, t, n) {
  Object.defineProperty(e, t, n);
}
function p(e, t, n) {
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
  Object.defineProperty(e, t, { value: n });
}

// src/constants.ts
<<<<<<< HEAD
var c = Symbol.for("tinyspy:spy");

// src/internal.ts
var d = /* @__PURE__ */ new Set(), q = (e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.next = [];
}, V = (e) => (f(e, c, { value: { reset: () => q(e[c]) } }), e[c]), I = (e) => e[c] || V(e);
function g(e) {
  R(u("function", e) || u("undefined", e), "cannot spy on a non-function value");
  let t = function(...s) {
    let r = I(t);
    r.called = !0, r.callCount++, r.calls.push(s);
    let m = r.next.shift();
    if (m) {
      r.results.push(m);
      let [l, o] = m;
      if (l === "ok")
        return o;
      throw o;
    }
    let p, x = "ok";
    if (r.impl)
      try {
        new.target ? p = Reflect.construct(r.impl, s, new.target) : p = r.impl.apply(this, s), x = "ok";
      } catch (l) {
        throw p = l, x = "error", r.results.push([x, l]), l;
      }
    let a = [x, p];
    if (b(p)) {
      let l = p.then((o) => a[1] = o).catch((o) => {
        throw a[0] = "error", a[1] = o, o;
      });
      Object.assign(l, p), p = l;
    }
    return r.results.push(a), p;
  };
  i(t, "_isMockFunction", !0), i(t, "length", e ? e.length : 0), i(t, "name", e && e.name || "spy");
  let n = I(t);
  return n.reset(), n.impl = e, t;
}
function A(e) {
  let t = I(e);
  f(e, "returns", {
    get: () => t.results.map(([, n]) => n)
  }), ["called", "callCount", "results", "calls", "reset", "impl"].forEach((n) => f(e, n, { get: () => t[n], set: (s) => t[n] = s })), i(e, "nextError", (n) => (t.next.push(["error", n]), t)), i(e, "nextResult", (n) => (t.next.push(["ok", n]), t));
=======
var u = Symbol.for("tinyspy:spy");

// src/internal.ts
var x = /* @__PURE__ */ new Set(), q = (e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.next = [];
}, V = (e) => (d(e, u, { value: { reset: () => q(e[u]) } }), e[u]), T = (e) => e[u] || V(e);
function I(e) {
  m(y("function", e) || y("undefined", e), "cannot spy on a non-function value");
  let t = function(...a) {
    let r = T(t);
    r.called = !0, r.callCount++, r.calls.push(a);
    let i = r.next.shift();
    if (i) {
      r.results.push(i);
      let [s, l] = i;
      if (s === "ok")
        return l;
      throw l;
    }
    let o, c = "ok";
    if (r.impl)
      try {
        new.target ? o = Reflect.construct(r.impl, a, new.target) : o = r.impl.apply(this, a), c = "ok";
      } catch (s) {
        throw o = s, c = "error", r.results.push([c, s]), s;
      }
    let S = [c, o];
    if (b(o)) {
      let s = o.then((l) => S[1] = l).catch((l) => {
        throw S[0] = "error", S[1] = l, l;
      });
      Object.assign(s, o), o = s;
    }
    return r.results.push(S), o;
  };
  p(t, "_isMockFunction", !0), p(t, "length", e ? e.length : 0), p(t, "name", e && e.name || "spy");
  let n = T(t);
  return n.reset(), n.impl = e, t;
}
function v(e) {
  let t = T(e);
  d(e, "returns", {
    get: () => t.results.map(([, n]) => n)
  }), ["called", "callCount", "results", "calls", "reset", "impl"].forEach((n) => d(e, n, { get: () => t[n], set: (a) => t[n] = a })), p(e, "nextError", (n) => (t.next.push(["error", n]), t)), p(e, "nextResult", (n) => (t.next.push(["ok", n]), t));
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
}

// src/spy.ts
function _(e) {
<<<<<<< HEAD
  let t = g(e);
  return A(t), t;
}

// src/spyOn.ts
var k = (e, t) => Object.getOwnPropertyDescriptor(e, t), P = (e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
};
function K(e, t, n) {
  R(!u("undefined", e), "spyOn could not find an object to spy upon"), R(u("object", e) || u("function", e), "cannot spyOn on a primitive value");
  let [s, r] = (() => {
    if (!u("object", t))
=======
  let t = I(e);
  return v(t), t;
}

// src/spyOn.ts
var P = (e, t) => Object.getOwnPropertyDescriptor(e, t);
function K(e, t, n) {
  m(!y("undefined", e), "spyOn could not find an object to spy upon"), m(y("object", e) || y("function", e), "cannot spyOn on a primitive value");
  let a = () => {
    if (!y("object", t))
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
<<<<<<< HEAD
  })(), m = k(e, s), p = Object.getPrototypeOf(e), x = p && k(p, s), a = m || x;
  R(a || s in e, `${String(s)} does not exist`);
  let l = !1;
  r === "value" && a && !a.value && a.get && (r = "get", l = !0, n = a.get());
  let o;
  a ? o = a[r] : r !== "value" ? o = () => e[s] : o = e[s], n || (n = o);
  let y = g(n);
  r === "value" && P(y, o);
  let O = (v) => {
    let { value: H, ...h } = a || {
      configurable: !0,
      writable: !0
    };
    r !== "value" && delete h.writable, h[r] = v, f(e, s, h);
  }, C = () => a ? f(e, s, a) : O(o), T = y[c];
  return i(T, "restore", C), i(T, "getOriginal", () => l ? o() : o), i(T, "willCall", (v) => (T.impl = v, y)), O(l ? () => (P(y, n), y) : y), d.add(y), y;
}
function $(e, t, n) {
  let s = K(e, t, n);
  return A(s), ["restore", "getOriginal", "willCall"].forEach((r) => {
    i(s, r, s[c][r]);
  }), s;
=======
  }, [r, i] = a(), o = P(e, r), c = Object.getPrototypeOf(e), S = c && P(c, r), s = o || S;
  m(s || r in e, `${String(r)} does not exist`);
  let l = !1;
  i === "value" && s && !s.value && s.get && (i = "get", l = !0, n = s.get());
  let f;
  s ? f = s[i] : i !== "value" ? f = () => e[r] : f = e[r], n || (n = f);
  let R = I(n), O = (h) => {
    let { value: H, ...w } = s || {
      configurable: !0,
      writable: !0
    };
    i !== "value" && delete w.writable, w[i] = h, d(e, r, w);
  }, M = () => s ? d(e, r, s) : O(f), A = R[u];
  return p(A, "restore", M), p(A, "getOriginal", () => l ? f() : f), p(A, "willCall", (h) => (A.impl = h, R)), O(l ? () => R : R), x.add(R), R;
}
function $(e, t, n) {
  let a = K(e, t, n);
  return v(a), ["restore", "getOriginal", "willCall"].forEach((r) => {
    p(a, r, a[u][r]);
  }), a;
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
}

// src/restoreAll.ts
function z() {
<<<<<<< HEAD
  for (let e of d)
    e.restore();
  d.clear();
=======
  for (let e of x)
    e.restore();
  x.clear();
>>>>>>> fd0cd07a55af4b1604432e584ca3d417e31428d1
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createInternalSpy,
  getInternalState,
  internalSpyOn,
  restoreAll,
  spies,
  spy,
  spyOn
});
